<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <style>
    /* Asegura que el sketch ocupe todo el espacio del iframe sin márgenes */
    body { margin: 0; padding: 0; background-color: #000; overflow: hidden; }
    canvas { display: block; width: 100vw !important; height: 100vh !important; object-fit: cover; }
  </style>
</head>
<body>
<script>
/**
 * Prueba de Esteroscopia 3D con Selector de Escenas
 * Versión: FINAL OPTIMIZADA (Lerp + Rescaling + Sleep Mode)
 * Autor: alareta
 * Licencia: MIT
 */

let img, depthMap, view, zBuffer;
const MAX_DISPARITY = 18; 
let lastMouseX = 0;
let mouseInteractionTimer = 0;
let currentT = 0;
let RES = 0.7; // Factor de resolución interna para rendimiento

function preload() {
  let params = getURLParams();
  // URLs por defecto (puedes cambiarlas por las tuyas)
  let defaultImg = "https://raw.githubusercontent.com/alareta/Estereoscopia/main/imagenes/1_imagen.jpg";
  let defaultDepth = "https://raw.githubusercontent.com/alareta/Estereoscopia/main/imagenes/1_profundidad.png";
  
  img = loadImage(params.img || defaultImg);
  depthMap = loadImage(params.depth || defaultDepth);
}

function setup() {
  // Crea el canvas al tamaño de la ventana (el iframe)
  createCanvas(windowWidth, windowHeight);
  pixelDensity(1); // Evita lag en pantallas Retina/4K
  inicializarBuffers();
  procesarImagen();
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
  inicializarBuffers();
  procesarImagen();
}

function procesarImagen() {
  if (img.width > 0 && depthMap.width > 0) {
    // Calculamos dimensiones internas basadas en el tamaño actual del canvas
    let internalW = floor(width * RES);
    let internalH = floor(height * RES);
    
    img.resize(internalW, internalH); 
    depthMap.resize(internalW, internalH);
    img.loadPixels();
    depthMap.loadPixels();
  }
}

function inicializarBuffers() {
  let internalW = floor(width * RES);
  let internalH = floor(height * RES);
  view = createImage(internalW, internalH);
  zBuffer = new Float32Array(internalW * internalH);
}

function draw() {
  if (!img.pixels.length || !depthMap.pixels.length) return;

  let targetT = 0;
  if (abs(mouseX - lastMouseX) > 0.1) mouseInteractionTimer = 40; 
  
  if (mouseInteractionTimer > 0) {
    targetT = map(mouseX, 0, width, -1, 1, true);
    mouseInteractionTimer--;
  } else {
    targetT = sin(frameCount * 0.05); 
  }
  lastMouseX = mouseX;

  if (abs(targetT - currentT) < 0.0005) return; 

  background(0); 
  currentT = lerp(currentT, targetT, 0.1);
  generateView(currentT, MAX_DISPARITY);
  
  // Dibujamos el buffer escalado al tamaño del canvas
  image(view, 0, 0, width, height);
}

function generateView(t, maxDisparity) {
  let iW = view.width;
  let iH = view.height;
  view.loadPixels();
  zBuffer.fill(-1);

  for (let y = 0; y < iH; y++) {
    for (let x = 0; x < iW; x++) {
      let idx = x + y * iW; 
      let p = idx * 4; 
      let d = depthMap.pixels[p] / 255;
      d = 1.0 - pow(1.0 - d, 1.2); 

      let shift = int((d - 0.5) * maxDisparity * t);
      let tx = x + shift;

      if (tx >= 0 && tx < iW) { 
        let tidx = tx + y * iW; 
        if (d > zBuffer[tidx]) {
          let tp = tidx * 4;
          view.pixels[tp]     = img.pixels[p];
          view.pixels[tp + 1] = img.pixels[p + 1];
          view.pixels[tp + 2] = img.pixels[p + 2];
          view.pixels[tp + 3] = 255;
          zBuffer[tidx] = d;
        }
      }
    }
  }
  view.updatePixels();
}
</script>
</body>
</html>