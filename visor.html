<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <style>
    /* Reset total para eliminar márgenes y scrolls */
    body { 
      margin: 0; 
      padding: 0; 
      background-color: #000; 
      overflow: hidden; 
      display: flex; 
      justify-content: center; 
      align-items: center; 
      height: 100vh; 
      width: 100vw;
    }
    
    /* El canvas será cuadrado y se adaptará al menor de los dos ejes */
    canvas { 
      max-width: 100%; 
      max-height: 100%; 
      width: auto !important; 
      height: auto !important; 
      aspect-ratio: 1 / 1; 
      object-fit: contain;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
<script>
/**
 * Prueba de Esteroscopia 3D con Selector de Escenas
 * Versión: FINAL OPTIMIZADA (Lerp + Rescaling + Sleep Mode)
 * Autor: alareta
 * Licencia: MIT
 */
/**
 * Versión Forzada 800x800 Responsive
 */

let img, depthMap, view, zBuffer;
const MAX_DISPARITY = 18; 
let lastMouseX = 0;
let mouseInteractionTimer = 0;
let currentT = 0;
let RES = 0.7; 

// Fijamos la resolución base de trabajo
const BASE_SIZE = 600;

function preload() {
  let params = getURLParams();
  let defaultImg = "https://raw.githubusercontent.com/alareta/Estereoscopia/main/imagenes/1_imagen.jpg";
  let defaultDepth = "https://raw.githubusercontent.com/alareta/Estereoscopia/main/imagenes/1_profundidad.png";
  
  img = loadImage(params.img || defaultImg);
  depthMap = loadImage(params.depth || defaultDepth);
}

function setup() {
  // Creamos el lienzo siempre a 600x600. 
  // El CSS se encargará de encogerlo visualmente si el iframe es pequeño.
  createCanvas(BASE_SIZE, BASE_SIZE);
  pixelDensity(1);
  inicializarBuffers();
  procesarImagen();
}

function inicializarBuffers() {
  // Trabajamos internamente a 600 * RES (al 0,7) para que vuele
  let internalW = floor(width * RES);
  let internalH = floor(height * RES);
  view = createImage(internalW, internalH);
  zBuffer = new Float32Array(internalW * internalH);
}

function procesarImagen() {
  if (img.width > 0 && depthMap.width > 0) {
    let internalW = floor(width * RES);
    let internalH = floor(height * RES);
    img.resize(internalW, internalH); 
    depthMap.resize(internalW, internalH);
    img.loadPixels();
    depthMap.loadPixels();
  }
}

function draw() {
  if (!img.pixels.length || !depthMap.pixels.length) return;

  let targetT = 0;
  if (abs(mouseX - lastMouseX) > 0.1) mouseInteractionTimer = 40; 
  
  if (mouseInteractionTimer > 0) {
    // IMPORTANTE: Mapeamos mouseX respecto al ancho real del canvas (width)
    targetT = map(mouseX, 0, width, -1, 1, true);
    mouseInteractionTimer--;
  } else {
    targetT = sin(frameCount * 0.05); 
  }
  lastMouseX = mouseX;

  if (abs(targetT - currentT) < 0.0005) return; 

  background(0); 
  currentT = lerp(currentT, targetT, 0.1);
  generateView(currentT, MAX_DISPARITY);
  
  // Dibujamos el buffer escalado para llenar los 800x800
  image(view, 0, 0, width, height);
}

function generateView(t, maxDisparity) {
  let iW = view.width;
  let iH = view.height;
  view.loadPixels();
  zBuffer.fill(-1);

  for (let y = 0; y < iH; y++) {
    for (let x = 0; x < iW; x++) {
      let idx = x + y * iW; 
      let p = idx * 4; 
      let d = depthMap.pixels[p] / 255;
      d = 1.0 - pow(1.0 - d, 1.2); 

      let shift = int((d - 0.5) * maxDisparity * t);
      let tx = x + shift;

      if (tx >= 0 && tx < iW) { 
        let tidx = tx + y * iW; 
        if (d > zBuffer[tidx]) {
          let tp = tidx * 4;
          view.pixels[tp]     = img.pixels[p];
          view.pixels[tp + 1] = img.pixels[p + 1];
          view.pixels[tp + 2] = img.pixels[p + 2];
          view.pixels[tp + 3] = 255;
          zBuffer[tidx] = d;
        }
      }
    }
  }
  view.updatePixels();
}
</script>
</body>
</html>