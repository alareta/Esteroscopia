<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <style>
    body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #fff; overflow: hidden; font-family: sans-serif; }
    canvas { max-width: 100%; max-height: 100%; object-fit: contain; image-rendering: pixelated; }
    /* Estilo para el selector */
    select { position: absolute; top: 10px; left: 10px; z-index: 10; padding: 5px; border-radius: 4px; background: rgba(255,255,255,0.8); }
  </style>
</head>
<body>
<script>
/**
 * Prueba de Esteroscopia 3D con Selector de Escenas
 * Autor: alareta (Optimizado)
 * Licencia: MIT
 */

let img, depthMap, view, zBuffer;
let selector;
const MAX_DISPARITY = 18; 
let lastMouseX = 0;
let mouseInteractionTimer = 0;

// Configuración de Resolución
const W = 800; // Ancho visual en pantalla
const H = 800; // Alto visual en pantalla
const RES = 0.7; // 0.5 = Mitad de resolución (Mejor rendimiento)

// Dimensiones internas de cálculo
let internalW = W * RES;
let internalH = H * RES;

// Variable para el suavizado (Lerp)
let currentT = 0;

const escenas = [
  { nombre: "Escena 1", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/1_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/1_profundidad.png" },
  { nombre: "Escena 2", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/2_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/2_profundidad.png" },
  { nombre: "Escena 3", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/3_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/3_profundidad.png" },
  { nombre: "Escena 4", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/4_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/4_profundidad.png" },
  { nombre: "Escena 5", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/5_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/5_profundidad.png" },
  { nombre: "Escena 6", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/6_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/6_profundidad.png" }
];

function preload() {
  cargarImagenes(0);
}

function setup() {
  createCanvas(W, H); // Usamos las constantes W y H
  
  selector = createSelect();
  selector.style("position", "relative");
  selector.style("font-size", "18px");
  selector.style("color", "#FFFFFF");
  selector.style("background-color", "#000000");
  selector.position(40, 40);
  escenas.forEach((escena, index) => {
    selector.option(escena.nombre, index);
  });
  selector.changed(cambiarEscena);

  // Opcional: si quieres pixel art retro, descomenta esto:
  //noSmooth(); 
  
  inicializarBuffers();
  lastMouseX = mouseX;
}

function cargarImagenes(index) {
  img = loadImage(escenas[index].img, procesarImagen);
  depthMap = loadImage(escenas[index].depth, procesarImagen);
}

function procesarImagen() {
  if (img.width > 0 && depthMap.width > 0) {
    // Redimensionamos a la resolución interna (400x400)
    img.resize(internalW, internalH); 
    depthMap.resize(internalW, internalH);
    img.loadPixels();
    depthMap.loadPixels();
  }
}

function inicializarBuffers() {
  view = createImage(internalW, internalH);
  zBuffer = new Float32Array(internalW * internalH);
}

function cambiarEscena() {
  let index = selector.value();
  background(0);
  cargarImagenes(index);
}

function draw() {
  // 1. SEGURIDAD: Si no hay datos, mensaje de carga y salir
  if (!img || !depthMap || !img.pixels || !depthMap.pixels || img.pixels.length === 0) {
    background(0);
    fill(255);
    textAlign(CENTER);
    text("Cargando escena...", width/2, height/2);
    return;
  }

  // 2. CALCULAR OBJETIVOS
  let targetT = 0;
  
  if (abs(mouseX - lastMouseX) > 0.1) {
    mouseInteractionTimer = 40; 
  }
  
  if (mouseInteractionTimer > 0) {
    targetT = map(mouseX, 0, width, -1, 1, true);
    mouseInteractionTimer--;
  } else {
    targetT = sin(frameCount * 0.05); 
  }
  lastMouseX = mouseX;

  // 3. REPOSO (OPTIMIZACIÓN CLAVE)
  // Calculamos cuánto nos falta para llegar al objetivo
  let dist = abs(targetT - currentT);

  // Si estamos muy cerca (menos de 0.001) Y el mouse está quieto...
  // ¡No dibujes nada! Deja el último frame en pantalla tal cual está.
  if (dist < 0.0005 && mouseInteractionTimer <= 0) {
      return; // <--- SALIDA TEMPRANA: Ahorra CPU/Batería
  }

  // 4. SI LLEGAMOS AQUÍ, ES QUE HAY MOVIMIENTO
  background(0); // Solo borramos si vamos a dibujar algo nuevo

  // Aplicamos el movimiento
  currentT = lerp(currentT, targetT, 0.1);

  // Generamos la nueva vista
  generateView(currentT, MAX_DISPARITY);

  // Dibujamos
  image(view, 0, 0, width, height);
}

function generateView(t, maxDisparity) {
  // Aseguramos que view esté listo para escribir
  view.loadPixels();
  
  // Copiar fondo base (opcional, ayuda a reducir agujeros negros)
  // view.pixels.set(img.pixels); 
  
  // Limpiar Z-Buffer
  zBuffer.fill(-1);

  // Bucle usando dimensiones INTERNAS (internalW/H)
  for (let y = 0; y < internalH; y++) {
    for (let x = 0; x < internalW; x++) {
      
      let idx = x + y * internalW; 
      let p = idx * 4;             

      // Leemos profundidad (Canal Rojo)
      let d = depthMap.pixels[p] / 255;
      d = 1.0 - d; 
      d = pow(d, 1.2); 

      let shift = int((d - 0.5) * maxDisparity * t);
      let tx = x + shift;

      // Verificamos límites con internalW
      if (tx >= 0 && tx < internalW) { 
        let tidx = tx + y * internalW; 
        
        if (d > zBuffer[tidx]) {
          let tp = tidx * 4;
          
          view.pixels[tp]     = img.pixels[p];
          view.pixels[tp + 1] = img.pixels[p + 1];
          view.pixels[tp + 2] = img.pixels[p + 2];
          view.pixels[tp + 3] = 255;
          zBuffer[tidx] = d;
        }
      }
    }
  }
  view.updatePixels();
}

function keyPressed() {
  if (key === "s" || key === "S") saveCanvas("render_" + selector.value(), "png");
}
</script>
