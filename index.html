<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.js"></script>
  <style>
    body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #fff; overflow: hidden; font-family: sans-serif; }
    canvas { max-width: 100%; max-height: 100%; object-fit: contain; image-rendering: pixelated; }
    /* Estilo para el selector */
    select { position: absolute; top: 10px; left: 10px; z-index: 10; padding: 5px; border-radius: 4px; background: rgba(255,255,255,0.8); }
  </style>
</head>
<body>
<script>
/**
 * Prueba de Esteroscopia 3D con Selector de Escenas
 * Versión: FINAL OPTIMIZADA (Lerp + Rescaling + Sleep Mode)
 * Autor: alareta
 * Licencia: MIT
 */

let img, depthMap, view, zBuffer;
let selector;
const MAX_DISPARITY = 18; 
let lastMouseX = 0;
let mouseInteractionTimer = 0;

// --- CONFIGURACIÓN DE RENDIMIENTO ---
const W = 800;   // Ancho del canvas
const H = 800;   // Alto del canvas
const RES = 0.5; // 0.5 = 50% resolución (Mejor rendimiento)

// Dimensiones internas de cálculo
let internalW = W * RES;
let internalH = H * RES;

// Variable para el suavizado (Lerp)
let currentT = 0;

const escenas = [
  { nombre: "1 Córdoba", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/1_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/1_profundidad.png" },
  { nombre: "2 Málaga", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/2_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/2_profundidad.png" },
  { nombre: "3 Valencia", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/3_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/3_profundidad.png" },
  { nombre: "4 Granada", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/4_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/4_profundidad.png" },
  { nombre: "5 Valencia", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/5_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/5_profundidad.png" },
  { nombre: "6 Granada", img: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/6_imagen.jpg", depth: "https://raw.githubusercontent.com/alareta/Estereoscopia/refs/heads/main/imagenes/6_profundidad.png" }
];

function preload() {
  cargarImagenes(0);
}

function setup() {
  createCanvas(W, H);
  
  selector = createSelect();
  selector.style("position", "relative");
  selector.style("font-size", "18px");
  selector.style("color", "#FFFFFF");
  selector.style("background-color", "#000000");
  selector.position(20, 20);
  escenas.forEach((escena, index) => {
    selector.option(escena.nombre, index);
  });
  selector.changed(cambiarEscena);

  inicializarBuffers();
  lastMouseX = mouseX;
}

function cargarImagenes(index) {
  img = loadImage(escenas[index].img, procesarImagen);
  depthMap = loadImage(escenas[index].depth, procesarImagen);
}

function procesarImagen() {
  if (img.width > 0 && depthMap.width > 0) {
    // Redimensionamos a la resolución interna para ganar velocidad
    img.resize(internalW, internalH); 
    depthMap.resize(internalW, internalH);
    img.loadPixels();
    depthMap.loadPixels();
  }
}

function inicializarBuffers() {
  view = createImage(internalW, internalH);
  zBuffer = new Float32Array(internalW * internalH);
}

function cambiarEscena() {
  let index = selector.value();
  background(0);
  // Reiniciamos currentT para evitar saltos bruscos al cambiar
  currentT = 0; 
  cargarImagenes(index);
}

function draw() {
  // 1. SEGURIDAD: Si no hay datos cargados, salir.
  if (!img || !depthMap || !img.pixels || !depthMap.pixels || img.pixels.length === 0) {
    background(0);
    fill(255);
    textAlign(CENTER);
    text("Cargando...", width/2, height/2);
    return;
  }

  // 2. CALCULAR OBJETIVO
  let targetT = 0;
  
  // Detectar movimiento del mouse
  if (abs(mouseX - lastMouseX) > 0.1) {
    mouseInteractionTimer = 40; 
  }
  
  if (mouseInteractionTimer > 0) {
    // Modo interactivo
    targetT = map(mouseX, 0, width, -1, 1, true);
    mouseInteractionTimer--;
  } else {
    // Modo automático (Onda suave)
    targetT = sin(frameCount * 0.05); 
  }
  lastMouseX = mouseX;

  // 3. OPTIMIZACIÓN DE REPOSO (Early Exit)
  // Calculamos la diferencia entre donde estamos y donde queremos ir
  let diff = abs(targetT - currentT);

  // Si la diferencia es imperceptible, NO DIBUJAMOS NADA.
  // Esto baja el uso de CPU al mínimo.
  if (diff < 0.0005) {
      return; 
  }

  // 4. DIBUJAR (Solo si pasamos el filtro anterior)
  background(0); 

  // Aplicamos Lerp
  currentT = lerp(currentT, targetT, 0.1);

  generateView(currentT, MAX_DISPARITY);
  
  // Dibujamos estirando la imagen pequeña al tamaño del canvas
  image(view, 0, 0, width, height);
}

function generateView(t, maxDisparity) {
  view.loadPixels();
  zBuffer.fill(-1);

  // Bucle optimizado usando internalW / internalH
  for (let y = 0; y < internalH; y++) {
    for (let x = 0; x < internalW; x++) {
      
      let idx = x + y * internalW; 
      let p = idx * 4;             

      // Seguridad de array
      if (p >= depthMap.pixels.length) continue;

      let d = depthMap.pixels[p] / 255; // 0..1
      
      // Ajuste de curva de profundidad para dar mas realismo
      d = 1.0 - d; 
      d = pow(d, 1.2); 

      let shift = int((d - 0.5) * maxDisparity * t);
      let tx = x + shift;

      // Verificamos límites
      if (tx >= 0 && tx < internalW) { 
        let tidx = tx + y * internalW; 
        
        if (d > zBuffer[tidx]) {
          let tp = tidx * 4;
          // Escribimos el pixel desplazado
          view.pixels[tp]     = img.pixels[p];
          view.pixels[tp + 1] = img.pixels[p + 1];
          view.pixels[tp + 2] = img.pixels[p + 2];
          view.pixels[tp + 3] = 255;
          zBuffer[tidx] = d;
        }
      }
    }
  }
  view.updatePixels();
}

function keyPressed() {
  if (key === "s" || key === "S") saveCanvas("render_" + selector.value(), "png");
}
</script>
